---
title: "AFP_LongRead_Notebook"
author: "Sam Bogan and Nathan Surendran"
output:
  github_document: default
---

# Summary

This is an R markdown lab notebook for all research, wet lab work, and analyses related to a study on type AFP III evolution revealed by long read sequencing and genome assembly in Zoarcoid fishes. The 11 Zoarcoid species included in the study and Scorpaeiformes outgroups (sticklebacks) are indexed

File registry
1. Metadata
  + LongRead_SpeciesIDs.csv (index of species names and genome IDs)

\br

Below is a quick visual representation of the species' relatedness using the rfishtree time-calibrated phylogeny

```{r setup, include=FALSE}

knitr::opts_knit$set(root.dir = '~/Documents/GitHub/Long_AFP/')

# Load packages for plotting quick species tree
library(tidyverse)
library(fishtree)
library(ggtree)
library(MatrixModels)
library(rfishbase)
library(phytools)
library(ape)

```

What genomes are we working with?

```{r}

# Read in list of species
Species_df <- read.csv("LongRead_SpeciesIDs.csv")

# Print list to show which genomes came from public source vs. Kelley Lab
head(Species_df)

```

Extract and plot species phylogeny with important metadata

```{r}

# Extract eelpout phylogeny
species_phy <- fishtree_phylogeny(species = Species_df$Species_ID, type=c("phylogram"))

# How many species in phy object? 94
length(species_phy$tip.label)

# Plot multilocus phylogeny
ggtree(species_phy, layout = "rectangular", size = .75) +
  geom_tiplab(hjust = -0.05) +
  scale_shape_manual(values = c(19,1,NA), na.translate = F) +
  xlim(0, .75) +
  theme_tree() +
  labs(title = "Multilocus Rabosky FishTreeofLife phylogeny")

```

Make phylogeny w/ metadata

```{r, eval = FALSE}
## Import habitat metadata from FishBase
species_list <- tolower(gsub("_", " ", species_phy$tip.label))
  
species_dist <- data.frame(tip.label = tolower(distribution(species_list(Family = 
                                                                           c("Zoarcidae", "Anarhichadidae",
                                                                             "Bathymasteridae", "Pholidae",
                                                                             "Stichaeidae", "Gasterosteidae")))$Species),
                           Region = distribution(species_list(Family = c("Zoarcidae", "Anarhichadidae",
                                                                             "Bathymasteridae", "Pholidae",
                                                                             "Stichaeidae", "Gasterosteidae")))$FAO,
                           Lat = distribution(species_list(Family = c("Zoarcidae", "Anarhichadidae",
                                                                             "Bathymasteridae", "Pholidae",
                                                                             "Stichaeidae", "Gasterosteidae")))$LatDeg,
                           NS = distribution(species_list(Family = c("Zoarcidae", "Anarhichadidae",
                                                                             "Bathymasteridae", "Pholidae",
                                                                             "Stichaeidae", "Gasterosteidae")))$N_S)
distribution(species_list(Family = "Zoarcidae"))

# Create variable for whether row is Antarctic, Arctic, polar
species_dist$Polar <- ifelse(grepl("Arctic", species_dist$Region) == TRUE, "Arctic",
                             ifelse(grepl("Antarctic", species_dist$Region) == TRUE, "Antarctic",
                                    "Subpolar"))

## Combine latitude with Zoarcid phylogeny object and plot
species_phy$tip.label <- tolower(gsub("_", " ", species_phy$tip.label))

species_dist_filt <- filter(species_dist, tip.label %in% species_phy$tip.label)

#Summarize latitude
species_dist_sum <- summarySE(measurevar = "Lat",
                              groupvars = c("tip.label", "Polar"),
                              data = species_dist_filt)

# Colored plot
max_y <- max(species_phy$edge.length)

ggtree(species_phy, layout = "rectangular", 
       aes(color = Lat), size = .75) %<+% species_dist_sum +
  geom_tippoint(aes(shape = Polar), size = 3) +
  geom_tiplab(hjust = -0.05) +
  scale_shape_manual(values = c(19,1,NA), na.translate = F) +
  theme_tree() +
  geom_treescale(width = 20) +
  scale_color_viridis_c(direction = -1) +
  theme_classic(base_size = 20) +
  xlim(0, 100) +
  theme(legend.background = element_rect(fill = "transparent"),
        panel.background = element_rect(fill = "transparent"),
        strip.background = element_rect(fill = "transparent"),
        plot.background = element_rect(fill = "transparent", color = NA),
        axis.line = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        legend.text = element_text(size = 8)) +
  labs(color = "Latitude", shape = "Region") +
  geom_rect(xmin = max_y-2, xmax = max_y-3, ymin = -Inf, ymax = Inf, fill = "skyblue", alpha = 0.01, lty = 0) +
  geom_rect(xmin = max_y-10, xmax = max_y-15, ymin = -Inf, ymax = Inf, fill = "pink", alpha = 0.01, lty = 0)

```

# Species tree construction

### 10/26/2023 Running BUCSO on long read assemblies

NS: Ran a BUSCO analysis on the fasta genome data for eelpouts and zoarcoids.  Single seq files then compressed using tar.gz

The slurm job script below was ran for the following species:
* alupus
* aminor
* bsig
* byu
* cviol1
* gacul
* lmac1
* lpac
* melgel1
* norway
* oamb
* pgunn1

```{bash, eval = FALSE}


#!/bin/bash
#SBATCH --job-name=busco_assembly_stats_alupus
#SBATCH --time=0-12:00:00
#SBATCH --partition=Instruction
#SBATCH --mail-user=nsurendr@ucsc.edu
#SBATCH --mail-type=ALL
#SBATCH --output=busco_assembly.out
#SBATCH --error=busco_assembly.err
#SBATCH --ntasks=1
#SBATCH --ntasks-per-node=1
#SBATCH --cpus-per-task=16
#SBATCH --mem=6GB

module load hb hb-gnu busco/busco-5.4.7
busco -c 16 -i /hb/groups/kelley_training/assemblies/alupus.asm.p_ctg.fa -o busco_assembly_alupus --auto-lineage -m genome -f

```

### 10/29/2023 Running BUSCO_phylogenomics to create multiple gene trees

SB ran reran BUSCO on the 12 assemblies above using his HB allocation and input the BUSCO output to BUSCO_to_phylogeny pipeline described here: https://github.com/jamiemcg/BUSCO_phylogenomics

NS's BUSCO job's per species were moved to Archive directory

The job script below has an annotation for where NS would start the script since he has already run BUSCO on the 12 assemblies

Before running the job, install BUSCO_phylogenomics and its dependencies

```{bash, eval = FALSE}

# Clone and enter repo
git clone https://github.com/jamiemcg/BUSCO_phylogenomics

# Create supplementary conda environment
module load miniconda3.9

conda env create -p BUSCO_phylogenomics_supp

conda activate BUSCO_phylogenomics_supp

# Install the following packages
mamba install biopython
conda install -c bioconda muscle
conda install -c bioconda trimal
conda install -c bioconda fasttree
conda install -c bioconda iqtree

```

Here is the job script

```{bash, eval = FALSE}

#!/bin/bash
#SBATCH --job-name=BUSCO_to_phy
#SBATCH --time=0-48:00:00
#SBATCH --mail-user=snbogan@ucsc.edu
#SBATCH --mail-type=ALL
#SBATCH --output=BUSCO_to_phy.out
#SBATCH --error=BUSCO_to_phy.err
#SBATCH --ntasks=1
#SBATCH --ntasks-per-node=1
#SBATCH --cpus-per-task=16
#SBATCH --mem=12GB

# Load BUSCO and parallel
module load busco
module load parallel

# Go to home directory
cd /hb/home/snbogan/

# Make BUSCO_results directory
mkdir /hb/home/snbogan/PolarFish/Long_AFP/BUSCO_results

# Go to folder with .fa genomes
cd /hb/home/snbogan/PolarFish/Long_AFP/

# Run BUSCO in parallel
run_busco() {
    name=$(basename "$1" .fa)
    busco -c 8 -i "$name".fa -o busco_assembly_"$name" --auto-lineage -m genome -f
}

export -f run_busco

find . -maxdepth 1 -name "*.fa" | parallel -j2 run_busco {}

##################################
###### NS should start here ######
##################################

# Activate BUSCO_phylogenomics conda env
module load miniconda3.9
conda activate /hb/home/snbogan/BUSCO_phylogenomics_supp

# Go to working directory
cd /hb/home/snbogan/PolarFish/Long_AFP/

# Run pipeline command
python /hb/home/snbogan/BUSCO_phylogenomics/BUSCO_phylogenomics.py \
 -i BUSCO_results -o output_busco_phylogenomics -t 8

## If data look patchy, run python <python count_buscos.py -i BUSCO_runs>

```

### 10/31/2023 Creating species tree from supermatrix alignment

SB used IQtree to create a species tree from the BUSCO_phylogenomics supermatrix alignment. This was a first pass at creating a species tree. NS will reproduce the BUSCO_phylogenomics and IQtree analyses and then move forward on creating a consensus species tree from the BUSCO_phylogenomics output of multiple gene trees. This will also use IQtree. SB's supermatrix IQtree code is below.

```{bash, eval = FALSE}

#!/bin/bash
#SBATCH --job-name=IQtree_supermatrix
#SBATCH --time=0-12:00:00
#SBATCH --mail-user=snbogan@ucsc.edu
#SBATCH --mail-type=ALL
#SBATCH --output=IQtree_supermatrix.out
#SBATCH --error=IQtree_supermatrix.err
#SBATCH --ntasks=1
#SBATCH --ntasks-per-node=1
#SBATCH --cpus-per-task=8
#SBATCH --mem=12GB

# Activate BUSCO_phylogenomics conda env
module load miniconda3.9
conda activate /hb/home/snbogan/BUSCO_phylogenomics_supp

# Go to BUSCO_phylogenomics directory w/ supermatrix alignment
cd /hb/home/snbogan/PolarFish/Long_AFP/output_busco_phylogenomics/supermatrix

# Run phyml on supermatrix alignment
iqtree -s SUPERMATRIX.phylip -o busco_assembly_Gacul_UGA_v5_genomic -m WAG -redo

```

IQtree finished but the distance matrix and tree files do not seem to align. Something's up.

```{r}

# Read and print IQtree distance matrix
mldist <- as.data.frame(
  read.table("Trees/Supermatrix_IQtree_LG4M/SUPERMATRIX.phylip.txt")
  )

row.names(mldist) <- mldist$V1

mldist_matrix <- as.matrix(mldist[,-c(1)])

hc <- hclust(as.dist(mldist_matrix))

# Convert hierarchical clustering tree to a phylogenetic tree
dist_tree <- as.phylo(hc)

# Plot distance tree
ggtree(dist_tree, layout = "rectangular") +
  geom_tiplab() +
  geom_treescale(width = 0.10, x = 0) +
  xlim(0, .15) +
  labs(title = "IQtree distance tree")

# Read tree file
tree <- read.tree("Trees/Supermatrix_IQtree_LG4M/SUPERMATRIX.phylip.treefile")

tree$tip.label <- gsub("busco_assembly_", "", tree$tip.label)

tree <- reroot(tree,
               node.number = 6,
               position = .5*(max(tree$edge.length)))

ggtree(tree, layout = "rectangular") +
  geom_tiplab() +
  xlim(0, .125) +
  geom_treescale() +
  labs(title = "Rooted IQtree LG4M substitution model")

```

### 11/1/2023

SB reran IQtree job replacing substitution model w/ WAG. The goal is to simplify the model and hopefully resolve a better variable rate tree. It produced another faulty tree.

Next, SB rooted the tree by adding the parameter. The result looked better.

```{r}

# Read tree file
tree <- read.newick("Trees/Supermatrix_IQtree_WAGroot/SUPERMATRIX.phylip.treefile")

tree$tip.label <- gsub("busco_assembly_", "", tree$tip.label)

tree <- reroot(tree, 
             node.number = 12, 
             position = .5*(max(tree$edge.length)))

tree$tip.label <- c("Anarhichas minor", "Anarhichas lupus", "Lycodes diapterus", 
                    "Ophthalmolycus amberensis", "Lycodes pacificus", "Melanostigma gelatinosum",
                    "Lycodes platyrhinus", "Leptoclinus maculatus", "Pholis gunnellus", 
                    "Cebidichthys violaceus", "Bathymaster signatus", "Gasterosteus aculeatus")

busco_df <- read.csv(("Busco_results_genome_size.csv"))

# Plot
Fig_1A <- ggtree(tree, layout = "rectangular", size = 1.5) %<+% busco_df +
  geom_tiplab(color = "black", nudge_x = .005) +
  geom_tippoint(aes(size = log(Genome_size))) +
  geom_treescale(width = 0.025, offset = -.55) +
  scale_color_viridis_c(direction = -1) +
  theme(legend.position = "none") +
  xlim(0, .15)

# Export Fig 1B as png
png("~/Documents/GitHub/Long_AFP/Figures/Fig_1A.png", units = "in", width = 8, 
    height = 6, 
    res = 600)

Fig_1A
       


```


### 11/7/2023

Meeting w/ Ella Gustavson on reverse amplicon identification in Norway eelpout using PCR primers

Goal: We are going to automate Ella's amplicon ID'ing process during a 11/9/2023 meeting using an R script

Below is a list of Ella's steps for amplicon ID starting with forward and reverse primer set

Alignment
1. Create blast databases w/ parsed seqIDs
2. Two blasts: one with forward, one w/ reverse primer
2. From blast output, create table of hits and alignment metrics

### 11/15/2023

Creating multigene coalescence tree using Astral

```{bash, eval = FALSE}

#!/bin/bash
#SBATCH --job-name=astral_tree
#SBATCH --mail-user=snbogan@ucsc.edu
#SBATCH --mail-type=ALL
#SBATCH --output=astral_tree.out
#SBATCH --error=astral_tree.err
#SBATCH --time=01:00:00
#SBATCH --ntasks=1
#SBATCH --ntasks-per-node=1
#SBATCH --cpus-per-task=8
#SBATCH --mem=12GB

# Move to working directory
cd /hb/home/snbogan/PolarFish/Long_AFP/output_busco_phylogenomics/gene_trees_single_copy

# Load java
module load java

# Run ASTRAL to create the multigene consensus tree
java -jar /hb/home/snbogan/Astral/astral.5.7.8.jar \
-i /hb/home/snbogan/PolarFish/Long_AFP/output_busco_phylogenomics/gene_trees_single_copy/ALL.tree \
-o /hb/home/snbogan/PolarFish/Long_AFP/output_busco_phylogenomics/gene_trees_single_copy/ASTRAL_out.tree \
2>ASTRAL_out.log

echo "ASTRAL analysis complete."

```

Plot unrooted astral coalescence tree

```{r}

# Read in astral output tree
astral_tree <- read.tree("Trees/Astral/ASTRAL_out.tree")

# ggplot
astral_tree$tip.label <- gsub("busco_assembly_", "", astral_tree$tip.label)

astral_tree$edge.length <- ifelse(is.na(astral_tree$edge.length) == TRUE, 
                                  1, astral_tree$edge.length)

astral_tree <- reroot(astral_tree,
                      node.number = 1,
                      position = .5*(max(tree$edge.length)))

ggtree(astral_tree, layout = "rectangular") +
  geom_tiplab() + 
  geom_nodelab(vjust = -.75, hjust = 1.5, color = "blue") +
  geom_treescale(width = 1, offset = -.55) +
  xlim(0, 12) +
  labs(title = "Rooted astral multigene coalescence tree")

```
Looks like IQtree performed well. Let's move forward with creating a time-calibrated tree.

### 11/30/2023

A .Rmd for figures 1 and 2 of the manuscript was created under Figures.Rmd

# Gene tree construction

### 12/13/2023

Hand annotation of AFP regions was performed by SB using two fasta files of zoarcoid AFPs using the following blast parameters mimicking NCBI blastn 'more dissimilar sequences/discontinguous blast'.

AFPs were documented as putatively complete genes if they contained the following:

All blast outputs can be found in ~/Documents/GitHub/Long_AFP/Hand_Annot/Blasts

* Start codon
* Complete exons 1 and 2

```{bash, eval = FALSE}

blastn -query /path/to/query.fa \
       -subject /path/to/genome.fa \
       -out output.txt \
       -evalue 0.1 \
       -word_size 11 \
       -gapopen 5 \
       -gapextend 2 \
       -penalty -3 \
       -reward 2 \
       -dust yes \
       -soft_masking true \
       -task blastn

```

The resulting annotations are in the file AFP_SASA_SASB_ranges.csv and can be seen below:

```{r}

# Read in hand annotation csv and print
head(read.csv("AFP_SASA_SASB_ranges.csv"), n = 50)

```

The AFP fasta's used for AFP annotations were:

* J03924.1: Macrozoarces americanus antifreeze protein (OP5A) gene, complete cds (primary)
* JQ040521.1: Anarhichas lupus clone AWG1 type III antifreeze protein (AFP III) gene, complete cds

JQ040521.1 was used to double check species for which no apparent AFPs were annotated

### 01/02/2024

Hand annotations of SAS-A and SAS-B were performed by SB using G. aculeatus paralogs:

* NC_053220.1:c8556783-8553001 (SAS-A)
* NC_053220.1:c8562485-8557311 (SAS-B)

SAS-B was identified based on its homology to Zoarcoid AFP III orthologs

All blast outputs can be found in ~/Documents/GitHub/Long_AFP/Hand_Annot/Blasts

### 01/04/2024

A gene tree was constructed by converting hand annotations of SAS and AFP regions to .bed files by hand and extracting their underlying sequences using bedtools getfasta. FASTA files were then concatenated into one file and aligned using MAFFT and constructed into a phylogenetic tree using IQTREE.

Below is the code for FASTA extraction and concatenation

```{bash, eval = FALSE}

# Extract fasta sequencing using .bed coordinates
bedtools getfasta -fi /path/to/genome.fa \ 
-bed /path/to/coordinates.bed \
-fo /path/to/output.fa # Repeat across all SAS/AFP coordinates

```

```{bash, eval = FALSE}
#!/bin/bash

## Combine all fasta's using concat.sh in 'Scripts' folder
# Target directory containing .fa files
TARGET_DIR="/Users/sambogan/Documents/GitHub/Long_AFP/Hand_Annot/GetFast/concat"

# Output file
OUTPUT_FILE="combined.fa"

# Navigate to target directory
cd "$TARGET_DIR"

# Check if output file already exists
if [ -f "$OUTPUT_FILE" ]; then
    echo "Output file $OUTPUT_FILE already exists. Removing it."
    rm "$OUTPUT_FILE"
fi

# Concatenate all .fa files into one
for file in *.fa; do
    cat "$file" >> "$OUTPUT_FILE"
    echo "Concatenated $file"
done

echo "All .fa files have been concatenated into $OUTPUT_FILE."

```

The resulting concatentation of fasta sequences was aligned using MAFFT set to preset parameters at: https://www.ebi.ac.uk/Tools/msa/mafft/

The .fa alignment file was input to IQTREE set to automated substitution model selection and free rate variation = FALSE. The selected substitution model was K3Pu+F+G4.

The resulting IQTREE gene tree is stored under Trees/Gene_Trees/01042024_IQTREE_K3Pu+F+G4_SAS_AFP_genetree.newick and is shown here:

```{r}

# Read in IQTree gene tree
IQ_genetree <- read.tree("Trees/Gene_Trees/01042024_IQTREE_K3Pu+F+G4_SAS_AFP_genetree.newick")

# Create factor for AFPs and SAS genes
group_df <- data.frame(tip.label = IQ_genetree$tip.label,
  group = ifelse(
  grepl("SAS", IQ_genetree$tip.label), "SAS",
  ifelse(grepl("AFP", IQ_genetree$tip.label), "AFP", NA)))

IQ_genetree <- reroot(IQ_genetree, 
             node.number = 193, 
             position = .5*(max(tree$edge.length)))

# Plot tree
ggtree(IQ_genetree, aes(color = group), layout = "rectangular") %<+% group_df +
  geom_tiplab(size = 2, align = TRUE) +
  geom_treescale() +
  labs(title = "Rooted IQtree gene tree K3Pu+F+G4 substitution model")

# IQtree 2
IQ_genetree2 <- read.tree("Trees/Gene_Trees/02092024_MAFFT_AFP_SAS_Exons_IQTREE.newick")

# Create factor for AFPs and SAS genes
group_df2 <- data.frame(tip.label = IQ_genetree2$tip.label,
  group = ifelse(
  grepl("SAS", IQ_genetree2$tip.label), "SAS",
  ifelse(grepl("AFP", IQ_genetree2$tip.label), "AFP", NA)))

IQ_genetree2 <- reroot(IQ_genetree2, #181
             node.number = 60)

# Plot tree
ggtree(IQ_genetree2, aes(color = group), layout = "rectangular") %<+% group_df2 +
  geom_tiplab(size = 2, align = FALSE) +
  geom_treescale() +
  labs(title = "Rooted IQtree gene tree K2P+G4 substitution model")

```

As shown above, this preliminary analysis demonstrates two indpendent origins of AFP III genes arising from SAS. This is highly unlikely given the prior literature. The most derived clade of SAS genes should be inspected. The following explanations may explain this result:

* Derived SAS genes were incorrectly annotated as AFPs and only possess first and last exon of SAS-B.
* These derived SAS genes underwent relaxed constraint resemble AFPs in terms of their conserved exons 

Additionally, some sorting of SAS-A and SAS-B appears incorrect and needs to be inspected as well.

# Automating annotation of AFPs

Automated annotationw as performed using exonerate and the M. americanus AFP III protein sequence as a query

```{bash, eval = FALSE}

# Exonerate bash script
exonerate --model protein2genome --query Mamericanus_AFP.txt --target ~/Documents/GitHub/Long_AFP/Genomes/Oamb_GCA_024529925.1_ASM2452992v1_genomic.fna --showtargetgff TRUE --showquerygff FALSE > Oamb_AFP_exonerate_output.txt

# Convert exonerate's gff3 to a bed file using bedops and filter for exons
gff2bed < Oamb_AFP.gff3 > Oamb_AFP.bed


# Filter bed file for exons only
awk '$8 == "exon"' Oamb_AFP.bed > Oamb_AFP_exons.bed

# Extract fasta sequences of exons
bed tools getfasta -fi ~/Documents/GitHub/Long_AFP/Genomes/Oamb_GCA_024529925.1_ASM2452992v1_genomic.fna -bed Oamb_AFP_exons.bed -s > ~/Documents/GitHub/Long_AFP/Exonerate/FASTA/Oamb_AFP_exons.fa

# Concatentate exons 1 and 2
bash ~/Documents/GitHub/Long_AFP/Scripts/concat_fa_pairs.sh ~/Documents/GitHub/Long_AFP/Exonerate/FASTA/Oamb_AFP_exons.fa > ~/Documents/GitHub/Long_AFP/Exonerate/FASTA/Oamb_AFP_cds.fa

# Resulting fasta files of AFP exons 1/2 and SAS exons 1/6 were combined in a single fasta and aligned using mafft,

```

Here is the bash script for concatenating read pairs

```{r}

# Read in IQTree gene tree
IQtr_exonerate <- read.tree("Trees/Gene_Trees/02122024_MAFFT_Exonerate.newick")

# Create factor for AFPs and SAS genes
group_df <- data.frame(tip.label = IQtr_exonerate$tip.label,
  group = ifelse(
  grepl("SASA", IQtr_exonerate$tip.label), "SASA",
  ifelse(grepl("SASB", IQtr_exonerate$tip.label), "SASB",
  ifelse(grepl("AFP", IQtr_exonerate$tip.label), "AFP", NA))))

IQtr_exonerate <- reroot(IQtr_exonerate, 
             node.number = 71)

# Plot tree
ggtree(IQtr_exonerate, aes(color = group), layout = "rectangular") %<+% group_df +
  geom_tiplab(size = 1.5, align = FALSE) +
  geom_treescale() +
  labs(title = "Rooted IQtree gene tree (Exonerate)")

```

03/04/2024

Filter RepeatModeler/Masker gff annotations for scaffolds including syntenic or translocated AFP III genes

```{r}

# Create list of .gff files
setwd("~/Documents/GitHub/Long_AFP/RepeatModeler/repeatmasker_gffs/AFP_scaffolds/")

# Get the files names
AFP_gff_ls <- list.files(pattern = "*.gff")

# Read in .csv files listed in gffs
AFP_gffs <- lapply(AFP_gff_ls, ape::read.gff)

# Correct df names from AFP_gffs
names(AFP_gffs) <- gsub("_.*",
                        "",
                        AFP_gff_ls)

# Create data frame of AFP scaffolds for filtering
AFP_scaff_df <- data.frame(
  species = c("Alupus", "Aminor",
              "Lmac", "Lplaty",
              "Oamb", "Pgunn"),
  scaff = c("ptg000026l, ptg000054l", "ptg000017l, ptg000003l, ptg000020l",
            "JAVDOI010000015.1, JAVDOI010000034.1, JAVDOI010000050.1", "ptg000053l",
            "JAFEUB010000084.1", "OU342824.1")
  )

for_NS <- data.frame(
  species = c("Alupus", "Aminor",
              "Lmac", "Lplaty",
              "Oamb", "Pgunn"),
  scaff_synt = c("ptg000026l", "ptg000017l",
            "JAVDOI010000015.1, JAVDOI010000050.1", "ptg000053l",
            "JAFEUB010000084.1", "OU342824.1"),
  scaff_trans = c("ptg000054l" , "ptg000003l, ptg000020l",
                  "JAVDOI010000034.1" , NA,
                  NA, NA)
  )

write.csv(for_NS, "~/Documents/GitHub/Long_AFP/Exonerate/BED/syn_trans_scaff_index.csv",
          row.names = FALSE)

table(AFP_gffs$Alupus$seqid %in% as.data.frame(strsplit(AFP_scaff_df[1,2], split = ", "))[,1])

# Filter RepeatMasker gff's for scaffolds w AFPs
filt_gffs <- list()

for (i in seq_along(AFP_gffs)) {
  # Filter the data frame to keep rows where seqid contains string1 or string2
  filt_gffs[[i]] <- filter(
    AFP_gffs[[i]], seqid %in% as.data.frame(strsplit(AFP_scaff_df[i,2], split = ", "))[,1])
}

# Export filtered gffs
library(plyranges)

for (i in seq_along(filt_gffs)) {
  # Check if 'seqid' is a column name in the current data frame
  if ('seqid' %in% colnames(filt_gffs[[i]])) {
    # Change the name of the column from 'seqid' to '#seqid'
    colnames(filt_gffs[[i]])[colnames(filt_gffs[[i]]) == 'seqid'] <- '#seqid'
  }
}

for (i in seq_along(filt_gffs)) {
  file_name <- paste0("~/Documents/GitHub/Long_AFP/RepeatModeler/repeatmasker_gffs/AFP_scaffolds/filt/", names(AFP_gffs)[[i]], "_AFP_scaffold_REs.gff")
  write.table(filt_gffs[[i]], file_name, row.names = FALSE, quote = FALSE)
}


```

### 03/06/2024

Bash script for calculating N50s of fasta files

```{bash, eval = FALSE}

#!/bin/bash

# Replace 'genome.fasta' with the path to your actual FASTA file.
fasta_file="Gacul_GCA_016920845.1_GAculeatus_UGA_version5_genomic.fna" # Replace file with other genome assemblies

# Step 1: Extract sequence lengths.
awk '/^>/ {if (seqlen){print seqlen}; seqlen=0; next} {seqlen += length($0)} END {print seqlen}' $fasta_file > lengths.txt

# Step 2: Sort lengths in descending order.
sort -nr lengths.txt > sorted_lengths.txt

# Step 3: Calculate N50 and write it to a file.
awk '{sum += $0; if (sum >= total/2) {print $0 > "N50_value.txt"; exit}}' total=$(awk '{sum+=$0}END{print sum}' sorted_lengths.txt) sorted_lengths.txt

```

### 03/13/2024 Import and analyze bed files of AFP and RE/TE loci

```{r}

library(rtracklayer)
library(GenomicRanges)
library(plyranges)

## First, AFPs

# Create list of gff files in your directory
gff_files <- c(
  "~/Documents/GitHub/Long_AFP/AFP_TE_BEDs/BEDs/Alupus_AFP_exonerate_full.gff",
  "~/Documents/GitHub/Long_AFP/AFP_TE_BEDs/BEDs/Aminor_AFP_exonerate_full.gff",
  "~/Documents/GitHub/Long_AFP/AFP_TE_BEDs/BEDs/Lmac_AFP_exonerate_full.gff")

# Function to read each gff file into a GRanges object
gffs <- lapply(gff_files, function(x) import.gff(x))

# Next, REs and TEs
setwd("~/Documents/GitHub/Long_AFP/AFP_TE_BEDs/AFP_scaffold_RE_annots/")

bed_RE_files <- c(
"~/Documents/GitHub/Long_AFP/AFP_TE_BEDs/AFP_scaffold_RE_annots/Alupus_AFP_scaff_att.bed",
  "~/Documents/GitHub/Long_AFP/AFP_TE_BEDs/AFP_scaffold_RE_annots/Aminor_AFP_scaff_att.bed",
  "~/Documents/GitHub/Long_AFP/AFP_TE_BEDs/AFP_scaffold_RE_annots/Lmac_AFP_scaff_att.bed")

# Convert REs to granges object
bed_REs <- lapply(bed_RE_files, function(x) import.bed(x))

### Calculate distances and mean dist between AFPs and RE's for each species, grouping by translocations

## Filter AFP Granges for translocated and syntenic genes

# First, read in index of synt vs trans scaffolds
index <- filter(
  read.csv("~/Documents/GitHub/Long_AFP/AFP_TE_BEDs/syn_trans_scaff_index.csv"),
  species == "Alupus" |
  species == "Aminor" |
  species == "Lmac")

print(index)

# AFPs
Alupus_AFPsynt_gr <- gffs[[1]][seqnames(gffs[[1]]) %in% index$scaff_synt]
Aminor_AFPsynt_gr <- gffs[[2]][seqnames(gffs[[2]]) %in% index$scaff_synt]
Lmac_AFPsynt_gr <- gffs[[3]][seqnames(gffs[[3]]) %in% index$scaff_synt]

Alupus_AFPtrans_gr <- gffs[[1]][seqnames(gffs[[1]]) %in% index$scaff_trans]
Aminor_AFPtransA_gr <- gffs[[2]][seqnames(gffs[[2]]) == "ptg000003l"]
Aminor_AFPtransB_gr <- gffs[[2]][seqnames(gffs[[2]]) == "ptg000020l"]
Lmac_AFPtransA_gr <- gffs[[3]][seqnames(gffs[[3]]) == "JAVDOI010000034.1"]
Lmac_AFPtransB_gr <- gffs[[3]][seqnames(gffs[[3]]) == "JAVDOI010000050.1"]

# REs
Alupus_REsynt_gr <- bed_REs[[1]][seqnames(bed_REs[[1]]) %in% index$scaff_synt]
Aminor_REsynt_gr <- bed_REs[[2]][seqnames(bed_REs[[2]]) %in% index$scaff_synt]
Lmac_REsynt_gr <- bed_REs[[3]][seqnames(bed_REs[[3]]) %in% index$scaff_synt]

Alupus_REtrans_gr <- bed_REs[[1]][seqnames(bed_REs[[1]]) %in% index$scaff_trans]
Aminor_REtransA_gr <- bed_REs[[2]][seqnames(bed_REs[[2]]) == "ptg000003l"]
Aminor_REtransB_gr <- bed_REs[[2]][seqnames(bed_REs[[2]]) == "ptg000020l"]
Lmac_REtransA_gr <- bed_REs[[3]][seqnames(bed_REs[[3]]) == "JAVDOI010000034.1"]
Lmac_REtransB_gr <- bed_REs[[3]][seqnames(bed_REs[[3]]) == "JAVDOI010000050.1"]

```

NS - Make draft plot of REs and AFPs in syntenic and translocated regions of the three species that have translocations (imported above) 

```{r}

#Amended above with paths for NS local directory

install.packages("BiocManager")

BiocManager::install("plyranges")
BiocManager::install("Gviz")

library(rtracklayer)
library(GenomicRanges)
library(plyranges)

## First, AFPs

# Create list of gff files in your directory
gff_files <- c(
  "C:/Users/Nate/Long_AFP/AFP_TE_BEDs/BEDs/Alupus_AFP_exonerate_full.gff",
  "C:/Users/Nate/Long_AFP/AFP_TE_BEDs/BEDs/Aminor_AFP_exonerate_full.gff",
  "C:/Users/Nate/Long_AFP/AFP_TE_BEDs/BEDs/Lmac_AFP_exonerate_full.gff")

# Function to read each gff file into a GRanges object
gffs <- lapply(gff_files, function(x) import.gff(x))

# Next, REs and TEs
setwd("C:/Users/Nate/Long_AFP/AFP_TE_BEDs/AFP_scaffold_RE_annots/")

bed_RE_files <- c(
"C:/Users/Nate/Long_AFP/AFP_TE_BEDs/AFP_scaffold_RE_annots/Alupus_AFP_scaff_att.bed",
  "C:/Users/Nate/Long_AFP/AFP_TE_BEDs/AFP_scaffold_RE_annots/Aminor_AFP_scaff_att.bed",
  "C:/Users/Nate/Long_AFP/AFP_TE_BEDs/AFP_scaffold_RE_annots/Lmac_AFP_scaff_att.bed")

# Convert REs to granges object
bed_REs <- lapply(bed_RE_files, function(x) import.bed(x))

### Calculate distances and mean dist between AFPs and RE's for each species, grouping by translocations

## Filter AFP Granges for translocated and syntenic genes

index <- filter(
  read.csv("C:/Users/Nate/Long_AFP/AFP_TE_BEDs/syn_trans_scaff_index.csv"),
  species == "Alupus" |
  species == "Aminor" |
  species == "Lmac")


print(index)

# AFPs
Alupus_AFPsynt_gr <- gffs[[1]][seqnames(gffs[[1]]) %in% index$scaff_synt]
Aminor_AFPsynt_gr <- gffs[[2]][seqnames(gffs[[2]]) %in% index$scaff_synt]
Lmac_AFPsynt_gr <- gffs[[3]][seqnames(gffs[[3]]) %in% index$scaff_synt]

Alupus_AFPtrans_gr <- gffs[[1]][seqnames(gffs[[1]]) %in% index$scaff_trans]
Aminor_AFPtransA_gr <- gffs[[2]][seqnames(gffs[[2]]) == "ptg000003l"]
Aminor_AFPtransB_gr <- gffs[[2]][seqnames(gffs[[2]]) == "ptg000020l"]
Lmac_AFPtransA_gr <- gffs[[3]][seqnames(gffs[[3]]) == "JAVDOI010000034.1"]
Lmac_AFPtransB_gr <- gffs[[3]][seqnames(gffs[[3]]) == "JAVDOI010000050.1"]

# REs
Alupus_REsynt_gr <- bed_REs[[1]][seqnames(bed_REs[[1]]) %in% index$scaff_synt]
Aminor_REsynt_gr <- bed_REs[[2]][seqnames(bed_REs[[2]]) %in% index$scaff_synt]
Lmac_REsynt_gr <- bed_REs[[3]][seqnames(bed_REs[[3]]) %in% index$scaff_synt]

Alupus_REtrans_gr <- bed_REs[[1]][seqnames(bed_REs[[1]]) %in% index$scaff_trans]
Aminor_REtransA_gr <- bed_REs[[2]][seqnames(bed_REs[[2]]) == "ptg000003l"]
Aminor_REtransB_gr <- bed_REs[[2]][seqnames(bed_REs[[2]]) == "ptg000020l"]
Lmac_REtransA_gr <- bed_REs[[3]][seqnames(bed_REs[[3]]) == "JAVDOI010000034.1"]
Lmac_REtransB_gr <- bed_REs[[3]][seqnames(bed_REs[[3]]) == "JAVDOI010000050.1"]

library(Gviz)
library(GenomicRanges)
```

3/29/2024: NS - Below are 8 plots total: Alupus syntenic and translocated,
Aminor syntenic, translocated A and translocated B, and Lmac syntenic and
translocated A and B

Comments: Alupus translocated has a vector error, it is trying to load a vector
of around 25.7 Gb.  

Aminor translocated A and B only displays the AFP, the plots
need to be adjusted to show RE if they are present in the region.

Lmac syntenic has no data present in the object for granges (Lmac_AFPsynt_gr) so
when we plot the Lmac_AFPsynt_df we get the following error:

Error in if ((maxBase - minBase) 
== 0) { : missing value where TRUE/FALSE needed
```{r}
# Create a genome axis track using Alupus_AFPsynt/REsynt_df

Alupus_AFPsynt_df <- as.data.frame(Alupus_AFPsynt_gr)


Alupus_REsynt_df <- as.data.frame(Alupus_REsynt_gr)

Alupus_synt_min <- min(c(min(Alupus_AFPsynt_df$start),
                         min(Alupus_REsynt_df$start)))

Alupus_synt_max <- max(c(max(Alupus_AFPsynt_df$end),
                         max(Alupus_REsynt_df$end)))

genomeAxisTrack <- GenomeAxisTrack()

# Create annotation tracks for the Alupus synt GRanges objects
track1 <- AnnotationTrack(range = Alupus_AFPsynt_gr, name = "AFP", col = "blue",
                          options(ucscChromosomeNames = FALSE))
track2 <- AnnotationTrack(range = Alupus_REsynt_gr, name = "TE", col = "red" ,
                          options(ucscChromosomeNames = FALSE))

# Plot the Alupus synt tracks using the Alupus_AFPsynt_df start and end
plotTracks(list(genomeAxisTrack, track1, track2), 
           from = min(Alupus_AFPsynt_df$start), to = max(Alupus_AFPsynt_df$end))

```
```{r}
# Create a genome axis track using Alupus_AFPtrans/REtrans_df

Alupus_AFPtrans_df <- as.data.frame(Alupus_AFPtrans_gr)


Alupus_REtrans_df <- as.data.frame(Alupus_REtrans_gr)

Alupus_trans_min <- min(c(min(Alupus_AFPtrans_df$start),
                         min(Alupus_REtrans_df$start)))

Alupus_trans_max <- max(c(max(Alupus_AFPtrans_df$end),
                         max(Alupus_REtrans_df$end)))

filtered_gr <- Alupus_REtrans_gr[start(Alupus_REtrans_gr) >= min(Alupus_AFPtrans_df$start) & end(Alupus_REtrans_gr) <= max(Alupus_AFPtrans_df$end)]

genomeAxisTrack <- GenomeAxisTrack()

# Create annotation tracks for the Alupus trans GRanges objects
track1 <- AnnotationTrack(range = Alupus_AFPtrans_gr, name = "AFP", col = "blue",
                          options(ucscChromosomeNames = FALSE))
track2 <- AnnotationTrack(range = filtered_gr, name = "TE", col = "red" ,
                          options(ucscChromosomeNames = FALSE))

# Plot the Alupus trans tracks using the Alupus_AFPtrans_df start and end
plotTracks(list(genomeAxisTrack, track1, track2), 
           from = min(Alupus_AFPtrans_df$start), to = max(Alupus_AFPtrans_df$end))
```
```{r}
# Create a genome axis track using Aminor_AFPsynt/REsynt_df

Aminor_AFPsynt_df <- as.data.frame(Aminor_AFPsynt_gr)


Aminor_REsynt_df <- as.data.frame(Aminor_REsynt_gr)

Aminor_synt_min <- min(c(min(Aminor_AFPsynt_df$start),
                         min(Aminor_REsynt_df$start)))

Aminor_synt_max <- max(c(max(Aminor_AFPsynt_df$end),
                         max(Aminor_REsynt_df$end)))

genomeAxisTrack <- GenomeAxisTrack()

# Create annotation tracks for the Aminor synt GRanges objects
track1 <- AnnotationTrack(range = Aminor_AFPsynt_gr, name = "AFP", col = "blue",
                          options(ucscChromosomeNames = FALSE))
track2 <- AnnotationTrack(range = Aminor_REsynt_gr, name = "TE", col = "red" ,
                          options(ucscChromosomeNames = FALSE))

# Plot the Aminor synt tracks using the Aminor_AFPsynt_df start and end
plotTracks(list(genomeAxisTrack, track1, track2), 
           from = min(Aminor_AFPsynt_df$start), to = max(Aminor_AFPsynt_df$end))
```
```{r}
# Create a genome axis track using Aminor_AFPtransA/REtransA_df

Aminor_AFPtransA_df <- as.data.frame(Aminor_AFPtransA_gr)


Aminor_REtransA_df <- as.data.frame(Aminor_REtransA_gr)

Aminor_transA_min <- min(c(min(Aminor_AFPtransA_df$start),
                         min(Aminor_REtransA_df$start)))

Aminor_transA_max <- max(c(max(Aminor_AFPtransA_df$end),
                         max(Aminor_REtransA_df$end)))

genomeAxisTrack <- GenomeAxisTrack()

# Create annotation tracks for the Aminor transA GRanges objects
track1 <- AnnotationTrack(range = Aminor_AFPtransA_gr, name = "AFP", col = "blue",
                          options(ucscChromosomeNames = FALSE))
track2 <- AnnotationTrack(range = Aminor_REtransA_gr, name = "TE", col = "red" ,
                          options(ucscChromosomeNames = FALSE))

# Plot the Aminor transA tracks using the Aminor_AFPtransA_df start and end
plotTracks(list(genomeAxisTrack, track1, track2), 
           from = min(Aminor_AFPtransA_df$start)-10e3, to = max(Aminor_AFPtransA_df$end)+10e3)
```
```{r}
# Create a genome axis track using Aminor_AFPtransB/REtransB_df

Aminor_AFPtransB_df <- as.data.frame(Aminor_AFPtransB_gr)


Aminor_REtransB_df <- as.data.frame(Aminor_REtransB_gr)

Aminor_transB_min <- min(c(min(Aminor_AFPtransB_df$start),
                         min(Aminor_REtransB_df$start)))

Aminor_transB_max <- max(c(max(Aminor_AFPtransB_df$end),
                         max(Aminor_REtransB_df$end)))

genomeAxisTrack <- GenomeAxisTrack()

# Create annotation tracks for the Aminor transB GRanges objects
track1 <- AnnotationTrack(range = Aminor_AFPtransB_gr, name = "AFP", col = "blue",
                          options(ucscChromosomeNames = FALSE))
track2 <- AnnotationTrack(range = Aminor_REtransB_gr, name = "TE", col = "red" ,
                          options(ucscChromosomeNames = FALSE))

# Plot the Alupus tracks using the Aminor_AFPtransB_df start and end
plotTracks(list(genomeAxisTrack, track1, track2), 
           from = min(Aminor_AFPtransB_df$start), to = max(Aminor_AFPtransB_df$end))
```
```{r}
# Create a genome axis track using Lmac_AFPsynt/REsynt_df

Lmac_AFPsynt_df <- as.data.frame(Lmac_AFPsynt_gr)


Lmac_REsynt_df <- as.data.frame(Lmac_REsynt_gr)

Lmac_synt_min <- min(c(min(Lmac_AFPsynt_df$start),
                         min(Lmac_REsynt_df$start)))

Lmac_synt_max <- max(c(max(Lmac_AFPsynt_df$end),
                         max(Lmac_REsynt_df$end)))

genomeAxisTrack <- GenomeAxisTrack()

# Create annotation tracks for the Lmac synt GRanges objects
track1 <- AnnotationTrack(range = Lmac_AFPsynt_gr, name = "AFP", col = "blue",
                          options(ucscChromosomeNames = FALSE))
track2 <- AnnotationTrack(range = Lmac_REsynt_gr, name = "TE", col = "red" ,
                          options(ucscChromosomeNames = FALSE))

# Plot the Lmac tracks using the Lmac_AFPsynt_df start and end
plotTracks(list(genomeAxisTrack, track1, track2), 
           from = min(Lmac_AFPsynt_df$start), to = max(Lmac_AFPsynt_df$end))
```
```{r}
# Create a genome axis track using Lmac_AFPtransA/REtransA_df

Lmac_AFPtransA_df <- as.data.frame(Lmac_AFPtransA_gr)


Lmac_REtransA_df <- as.data.frame(Lmac_REtransA_gr)

Lmac_transA_min <- min(c(min(Lmac_AFPtransA_df$start),
                         min(Lmac_REtransA_df$start)))

Lmac_transA_max <- max(c(max(Lmac_AFPtransA_df$end),
                         max(Lmac_REtransA_df$end)))

genomeAxisTrack <- GenomeAxisTrack()

# Create annotation tracks for the Lmac transA GRanges objects
track1 <- AnnotationTrack(range = Lmac_AFPtransA_gr, name = "AFP", col = "blue",
                          options(ucscChromosomeNames = FALSE))
track2 <- AnnotationTrack(range = Lmac_REtransA_gr, name = "TE", col = "red" ,
                          options(ucscChromosomeNames = FALSE))

# Plot the Lmac tracks using the Lmac_AFPsynt_df start and end
plotTracks(list(genomeAxisTrack, track1, track2), 
           from = min(Lmac_AFPtransA_df$start), to = max(Lmac_AFPtransA_df$end))
```
```{r}
# Create a genome axis track using Lmac_AFPtransB/REtransB_df

Lmac_AFPtransB_df <- as.data.frame(Lmac_AFPtransB_gr)


Lmac_REtransB_df <- as.data.frame(Lmac_REtransB_gr)

Lmac_transB_min <- min(c(min(Lmac_AFPtransB_df$start),
                         min(Lmac_REtransB_df$start)))

Lmac_transB_max <- max(c(max(Lmac_AFPtransB_df$end),
                         max(Lmac_REtransB_df$end)))

genomeAxisTrack <- GenomeAxisTrack()

# Create annotation tracks for the Lmac transB GRanges objects
track1 <- AnnotationTrack(range = Lmac_AFPtransB_gr, name = "AFP", col = "blue",
                          options(ucscChromosomeNames = FALSE))
track2 <- AnnotationTrack(range = Lmac_REtransB_gr, name = "TE", col = "red" ,
                          options(ucscChromosomeNames = FALSE))

# Plot the Lmac tracks using the Lmac_AFPtransB_df start and end
plotTracks(list(genomeAxisTrack, track1, track2), 
           from = min(Lmac_AFPtransB_df$start), to = max(Lmac_AFPtransB_df$end))
```
Calc RE density as number of elements within AFP tandem array

```{r}
### Calc density of REs near synt/trans AFPs
## Density by bp
# Subset RE granges within AFP regions
Alupus_REsynt_f <- filter(Alupus_REsynt_gr,
                          start >= min(as.data.frame(Alupus_AFPsynt_gr)$start) &
                            end <= max(as.data.frame(Alupus_AFPsynt_gr)$end))

Aminor_REsynt_f <- filter(Aminor_REsynt_gr,
                          start >= min(as.data.frame(Aminor_AFPsynt_gr)$start) &
                            end <= max(as.data.frame(Aminor_AFPsynt_gr)$end))

Lmac_REsynt_f <- filter(Lmac_REsynt_gr,
                          start >= min(as.data.frame(Lmac_AFPsynt_gr)$start) &
                            end <= max(as.data.frame(Lmac_AFPsynt_gr)$end))

Alupus_REtrans_f <- filter(Alupus_REtrans_gr,
                          start >= min(as.data.frame(Alupus_AFPtrans_gr)$start) &
                            end <= max(as.data.frame(Alupus_AFPtrans_gr)$end))

Aminor_REtransA_f <- filter(Aminor_REtransA_gr,
                          start >= min(as.data.frame(Aminor_AFPtransA_gr)$start) &
                            end <= max(as.data.frame(Aminor_AFPtransA_gr)$end)) ### Empty because there is only one AFP - use proximity to object

Aminor_REtransB_f <- filter(Aminor_REtransA_gr,
                          start >= min(as.data.frame(Aminor_AFPtransB_gr)$start) &
                            end <= max(as.data.frame(Aminor_AFPtransB_gr)$end)) ### Empty because there is only one AFP - use proximity to object

Lmac_REtransA_f <- filter(Lmac_REtransA_gr,
                          start >= min(as.data.frame(Lmac_AFPtransA_gr)$start) &
                            end <= max(as.data.frame(Lmac_AFPtransA_gr)$end)) ### Empty because there is only one AFP - use proximity to object

Lmac_REtransB_f <- filter(Aminor_REtransA_gr,
                          start >= min(as.data.frame(Lmac_AFPtransB_gr)$start) &
                            end <= max(as.data.frame(Lmac_AFPtransB_gr)$end))

# Density by number of element
dens_n_df <- data.frame(species = c("Alupus", "Alupus",
                                    "Aminor", "Aminor", "Aminor",
                                    "Lmac", "Lmac", "Lmac"),
                        region = c("synt", "trans",
                                   "synt", "trans", "trans",
                                   "synt", "trans", "trans"),
                        AFP_n = c(5, 18,
                                  3, 1, 1,
                                  4, 17, 21),
                        RE_n = c(nrow(as.data.frame(Alupus_REsynt_f)), nrow(as.data.frame(Alupus_REtrans_f)),
                                 nrow(as.data.frame(Aminor_REsynt_f)), nrow(as.data.frame(Aminor_REtransA_f)),
                                 nrow(as.data.frame(Aminor_REtransB_f)),
                                 nrow(as.data.frame(Lmac_REsynt_f)), nrow(as.data.frame(Lmac_REtransA_f)),
                                 nrow(as.data.frame(Lmac_REtransB_f))))


ggplot(data = dens_n_df,
       aes(x = AFP_n, y = log(RE_n))) +
  geom_smooth(method = "lm", se = FALSE, color = "black") +
  geom_point(aes(shape = species, color = region)) +
  theme_classic()

```

Calc RE density as mean distance of AFPs to REs

```{r}

# Create data frame
dens_dist_df <- data.frame(species = c("Alupus", "Alupus",
                                    "Aminor", "Aminor", "Aminor",
                                    "Lmac", "Lmac", "Lmac"),
                        region = c("synt", "trans",
                                   "synt", "trans", "trans",
                                   "synt", "trans", "trans"),
                        AFP_n = c(5, 18,
                                  3, 1, 1,
                                  4, 17, 21),
                        RE_dist = c(mean(nearest(Alupus_AFPsynt_gr, Alupus_REsynt_gr, 
                                                 select=c("arbitrary", "all"), 
                                                 ignore.strand=TRUE)),
                                    mean(nearest(Alupus_AFPtrans_gr, Alupus_REtrans_gr, 
                                                 select=c("arbitrary", "all"), 
                                                 ignore.strand=TRUE)),
                                    mean(nearest(Aminor_AFPsynt_gr, Aminor_REsynt_gr, 
                                                 select=c("arbitrary", "all"), 
                                                 ignore.strand=TRUE)),
                                    mean(nearest(Aminor_AFPtransA_gr, Aminor_REtransA_gr, 
                                                 select=c("arbitrary", "all"), 
                                                 ignore.strand=TRUE)),
                                    mean(nearest(Aminor_AFPsynt_gr, Aminor_REtransB_gr, 
                                                 select=c("arbitrary", "all"), 
                                                 ignore.strand=TRUE)),
                                    mean(nearest(Lmac_AFPsynt_gr, Lmac_REsynt_gr, 
                                                 select=c("arbitrary", "all"), 
                                                 ignore.strand=TRUE)),
                                    mean(nearest(Lmac_AFPtransA_gr, Lmac_REtransA_gr, 
                                                 select=c("arbitrary", "all"), 
                                                 ignore.strand=TRUE)),
                                    mean(nearest(Lmac_AFPtransB_gr, Lmac_REtransB_gr, 
                                                 select=c("arbitrary", "all"), 
                                                 ignore.strand=TRUE))),
                        RE_sd = c(sd(nearest(Alupus_AFPsynt_gr, Alupus_REsynt_gr, 
                                                 select=c("arbitrary", "all"), 
                                                 ignore.strand=TRUE)),
                                    sd(nearest(Alupus_AFPtrans_gr, Alupus_REtrans_gr, 
                                                 select=c("arbitrary", "all"), 
                                                 ignore.strand=TRUE)),
                                    sd(nearest(Aminor_AFPsynt_gr, Aminor_REsynt_gr, 
                                                 select=c("arbitrary", "all"), 
                                                 ignore.strand=TRUE)),
                                    sd(nearest(Aminor_AFPtransA_gr, Aminor_REtransA_gr, 
                                                 select=c("arbitrary", "all"), 
                                                 ignore.strand=TRUE)),
                                    sd(nearest(Aminor_AFPtransB_gr, Aminor_REtransB_gr, 
                                                 select=c("arbitrary", "all"), 
                                                 ignore.strand=TRUE)),
                                    sd(nearest(Lmac_AFPsynt_gr, Lmac_REsynt_gr, 
                                                 select=c("arbitrary", "all"), 
                                                 ignore.strand=TRUE)),
                                    sd(nearest(Lmac_AFPtransA_gr, Lmac_REtransA_gr, 
                                                 select=c("arbitrary", "all"), 
                                                 ignore.strand=TRUE)),
                                    sd(nearest(Lmac_AFPsynt_gr, Lmac_REtransB_gr, 
                                                 select=c("arbitrary", "all"), 
                                                 ignore.strand=TRUE))))

# Plot it!
ggplot(data = dens_dist_df,
       aes(x = AFP_n, y = RE_dist)) +
  geom_smooth(method = "lm", se = FALSE, color = "black") +
  geom_point(aes(shape = species, color = region), size = 3) +
  theme_classic()

```

Filter RepeatModeler GRanges for TE's and plot, grouping by TE type

```{r}

## Create index of TE ID's and names

library(Biostrings)

# Function to read a FASTA file and extract names and annotations
readFastaAnnotations <- function(fastaFile) {
  # Read the FASTA file
  fastaSequences <- readDNAStringSet(filepath = fastaFile, format = "fasta")
  
  # Extract names (IDs) and descriptions
  names <- names(fastaSequences)
  descriptions <- sapply(strsplit(names, " "), `[`, 2)
  
  # Replace NA with empty strings if there are no descriptions
  descriptions[is.na(descriptions)] <- ""
  
  # Create a data frame to store the names and annotations
  data <- data.frame(Name = sapply(strsplit(names, " "), `[`, 1), 
                     Annotation = descriptions, stringsAsFactors = FALSE)
  
  return(data)
}

# Alupus
Alupus_RE_fa <- 
  "~/Documents/GitHub/Long_AFP/RepeatModeler/repeatmodeler_consensus_fastas/Alupus_consensus_sequences.fasta"

Alupus_RE_annot <- readFastaAnnotations(Alupus_RE_fa)

Alupus_RE_annot$Annotation <- gsub(".*#", "", Alupus_RE_annot$Name)
Alupus_RE_annot$Name <- gsub("#.*", "", Alupus_RE_annot$Name)

# Filter out Unknown, Simple_repeat, rRNA
Alupus_RE_annot <- filter(Alupus_RE_annot, Annotation != "Unknown" & 
                            Annotation != "Simple_repeat" & 
                            Annotation != "rRNA")

# Filter GRanges object for names that contain any of the substrings
filter_condition <- sapply(Alupus_RE_annot$Name, 
                           function(substring) grepl(substring, 
                                                     Alupus_REsynt_gr$name))

Alupus_TEsynt_gr <- Alupus_REsynt_gr[rowSums(filter_condition) > 0]

filter_condition <- sapply(Alupus_RE_annot$Name, 
                           function(substring) grepl(substring, 
                                                     Alupus_REtrans_gr$name))

Alupus_TEtrans_gr <- Alupus_REtrans_gr[rowSums(filter_condition) > 0]

# Aminor
Aminor_RE_fa <- 
  "~/Documents/GitHub/Long_AFP/RepeatModeler/repeatmodeler_consensus_fastas/Aminor_consensus_sequences.fasta"

Aminor_RE_annot <- readFastaAnnotations(Aminor_RE_fa)

Aminor_RE_annot$Annotation <- gsub(".*#", "", Aminor_RE_annot$Name)
Aminor_RE_annot$Name <- gsub("#.*", "", Aminor_RE_annot$Name)

# Filter out Unknown, Simple_repeat, rRNA
Aminor_RE_annot <- filter(Aminor_RE_annot, Annotation != "Unknown" & 
                            Annotation != "Simple_repeat" & 
                            Annotation != "rRNA")

filter_condition <- sapply(Aminor_RE_annot$Name, 
                           function(substring) grepl(substring, 
                                                     Aminor_REsynt_gr$name))

Aminor_TEsynt_gr <- Aminor_REsynt_gr[rowSums(filter_condition) > 0]

filter_condition <- sapply(Aminor_RE_annot$Name, 
                           function(substring) grepl(substring, 
                                                     Aminor_REtransA_gr$name))

Aminor_TEtransA_gr <- Aminor_REtransA_gr[rowSums(filter_condition) > 0]

filter_condition <- sapply(Aminor_RE_annot$Name, 
                           function(substring) grepl(substring, 
                                                     Aminor_REtransB_gr$name))

Aminor_TEtransB_gr <- Aminor_REtransB_gr[rowSums(filter_condition) > 0]

# Lmac
Lmac_RE_fa <- 
  "~/Documents/GitHub/Long_AFP/RepeatModeler/repeatmodeler_consensus_fastas/Lmac_consensus_sequences.fasta"

Lmac_RE_annot <- readFastaAnnotations(Lmac_RE_fa)

Lmac_RE_annot$Annotation <- gsub(".*#", "", Lmac_RE_annot$Name)
Lmac_RE_annot$Name <- gsub("#.*", "", Lmac_RE_annot$Name)

Lmac_RE_annot <- filter(Lmac_RE_annot, Annotation != "Unknown" & 
                            Annotation != "Simple_repeat" & 
                            Annotation != "rRNA")

filter_condition <- sapply(Lmac_RE_annot$Name, 
                           function(substring) grepl(substring, 
                                                     Lmac_REsynt_gr$name))

Lmac_TEsynt_gr <- Lmac_REsynt_gr[rowSums(filter_condition) > 0]

filter_condition <- sapply(Lmac_RE_annot$Name, 
                           function(substring) grepl(substring, 
                                                     Lmac_REtransA_gr$name))

Lmac_TEtransA_gr <- Lmac_REtransA_gr[rowSums(filter_condition) > 0]

filter_condition <- sapply(Lmac_RE_annot$Name, 
                           function(substring) grepl(substring, 
                                                     Lmac_REtransB_gr$name))

Lmac_TEtransB_gr <- Lmac_REtransB_gr[rowSums(filter_condition) > 0]

# Create AFP x TE density dataframe
TE_dist_df <- data.frame(species = c("Alupus", "Alupus",
                                    "Aminor", "Aminor", "Aminor",
                                    "Lmac", "Lmac", "Lmac"),
                        region = c("synt", "trans",
                                   "synt", "trans", "trans",
                                   "synt", "trans", "trans"),
                        AFP_n = c(5, 18,
                                  3, 1, 1,
                                  4, 17, 21),
                        TE_dist = c(mean(nearest(Alupus_AFPsynt_gr, Alupus_TEsynt_gr, 
                                                 select=c("arbitrary", "all"), 
                                                 ignore.strand=TRUE)),
                                    mean(nearest(Alupus_AFPtrans_gr, Alupus_TEtrans_gr, 
                                                 select=c("arbitrary", "all"), 
                                                 ignore.strand=TRUE)),
                                    mean(nearest(Aminor_AFPsynt_gr, Aminor_TEsynt_gr, 
                                                 select=c("arbitrary", "all"), 
                                                 ignore.strand=TRUE)),
                                    mean(nearest(Aminor_AFPtransA_gr, Aminor_TEtransA_gr, 
                                                 select=c("arbitrary", "all"), 
                                                 ignore.strand=TRUE)),
                                    mean(nearest(Aminor_AFPtransB_gr, Aminor_TEtransB_gr, 
                                                 select=c("arbitrary", "all"), 
                                                 ignore.strand=TRUE)),
                                    mean(nearest(Lmac_AFPsynt_gr, Lmac_TEsynt_gr, 
                                                 select=c("arbitrary", "all"), 
                                                 ignore.strand=TRUE)),
                                    mean(nearest(Lmac_AFPtransA_gr, Lmac_TEtransA_gr, 
                                                 select=c("arbitrary", "all"), 
                                                 ignore.strand=TRUE)),
                                    mean(nearest(Lmac_AFPtransB_gr, Lmac_TEtransB_gr, 
                                                 select=c("arbitrary", "all"), 
                                                 ignore.strand=TRUE))),
                        TE_sd = c(sd(nearest(Alupus_AFPsynt_gr, Alupus_TEsynt_gr, 
                                                 select=c("arbitrary", "all"), 
                                                 ignore.strand=TRUE)),
                                    sd(nearest(Alupus_AFPtrans_gr, Alupus_TEtrans_gr, 
                                                 select=c("arbitrary", "all"), 
                                                 ignore.strand=TRUE)),
                                    sd(nearest(Aminor_AFPsynt_gr, Aminor_TEsynt_gr, 
                                                 select=c("arbitrary", "all"), 
                                                 ignore.strand=TRUE)),
                                    sd(nearest(Aminor_AFPtransA_gr, Aminor_TEtransA_gr, 
                                                 select=c("arbitrary", "all"), 
                                                 ignore.strand=TRUE)),
                                    sd(nearest(Aminor_AFPsynt_gr, Aminor_TEtransB_gr, 
                                                 select=c("arbitrary", "all"), 
                                                 ignore.strand=TRUE)),
                                    sd(nearest(Lmac_AFPsynt_gr, Lmac_TEsynt_gr, 
                                                 select=c("arbitrary", "all"), 
                                                 ignore.strand=TRUE)),
                                    sd(nearest(Lmac_AFPtransA_gr, Lmac_TEtransA_gr, 
                                                 select=c("arbitrary", "all"), 
                                                 ignore.strand=TRUE)),
                                    sd(nearest(Lmac_AFPsynt_gr, Lmac_TEtransB_gr, 
                                                 select=c("arbitrary", "all"), 
                                                 ignore.strand=TRUE))))

# Plot it!
ggplot(data = TE_dist_df,
       aes(x = AFP_n, y = TE_dist)) +
  geom_smooth(method = "lm", se = FALSE, color = "black") +
  geom_point(aes(shape = species, color = region), size = 3) +
  theme_classic()

```

Regress AFP CNV and number of TEs within AFP tandem arrays

```{r}

# Subset TE granges within AFP regions
Alupus_TEsynt_f <- filter(Alupus_TEsynt_gr,
                          start >= min(as.data.frame(Alupus_AFPsynt_gr)$start) &
                            end <= max(as.data.frame(Alupus_AFPsynt_gr)$end))

Aminor_TEsynt_f <- filter(Aminor_TEsynt_gr,
                          start >= min(as.data.frame(Aminor_AFPsynt_gr)$start) &
                            end <= max(as.data.frame(Aminor_AFPsynt_gr)$end))

Lmac_TEsynt_f <- filter(Lmac_TEsynt_gr,
                          start >= min(as.data.frame(Lmac_AFPsynt_gr)$start) &
                            end <= max(as.data.frame(Lmac_AFPsynt_gr)$end))

Alupus_TEtrans_f <- filter(Alupus_TEtrans_gr,
                          start >= min(as.data.frame(Alupus_AFPtrans_gr)$start) &
                            end <= max(as.data.frame(Alupus_AFPtrans_gr)$end))

Aminor_TEtransA_f <- filter(Aminor_TEtransA_gr,
                          start >= min(as.data.frame(Aminor_AFPtransA_gr)$start) &
                            end <= max(as.data.frame(Aminor_AFPtransA_gr)$end)) ### Empty because there is only one AFP - use proximity to object

Aminor_TEtransB_f <- filter(Aminor_TEtransB_gr,
                          start >= min(as.data.frame(Aminor_AFPtransB_gr)$start) &
                            end <= max(as.data.frame(Aminor_AFPtransB_gr)$end)) ### Empty because there is only one AFP - use proximity to object

Lmac_TEtransA_f <- filter(Lmac_TEtransA_gr,
                          start >= min(as.data.frame(Lmac_AFPtransA_gr)$start) &
                            end <= max(as.data.frame(Lmac_AFPtransA_gr)$end)) ### Empty because there is only one AFP - use proximity to object

Lmac_TEtransB_f <- filter(Aminor_TEtransB_gr,
                          start >= min(as.data.frame(Lmac_AFPtransB_gr)$start) &
                            end <= max(as.data.frame(Lmac_AFPtransB_gr)$end))

# Density by number of element
TE_n_df <- data.frame(species = c("Alupus", "Alupus",
                                    "Aminor", "Aminor", "Aminor",
                                    "Lmac", "Lmac", "Lmac"),
                        region = c("synt", "trans",
                                   "synt", "trans", "trans",
                                   "synt", "trans", "trans"),
                        AFP_n = c(5, 18,
                                  3, 1, 1,
                                  4, 17, 21),
                        TE_n = c(nrow(as.data.frame(Alupus_TEsynt_f)), nrow(as.data.frame(Alupus_TEtrans_f)),
                                 nrow(as.data.frame(Aminor_TEsynt_f)), nrow(as.data.frame(Aminor_TEtransA_f)),
                                 nrow(as.data.frame(Aminor_TEtransB_f)),
                                 nrow(as.data.frame(Lmac_TEsynt_f)), nrow(as.data.frame(Lmac_TEtransA_f)),
                                 nrow(as.data.frame(Lmac_TEtransB_f))),
                        len = c((max(as.data.frame(Alupus_AFPsynt_gr)$end) - 
                                  min(as.data.frame(Alupus_AFPsynt_gr)$start)),
                                (max(as.data.frame(Alupus_AFPtrans_gr)$end) - 
                                  min(as.data.frame(Alupus_AFPtrans_gr)$start)),
                                (max(as.data.frame(Aminor_AFPsynt_gr)$end) - 
                                  min(as.data.frame(Aminor_AFPsynt_gr)$start)),
                                (max(as.data.frame(Aminor_AFPtransA_gr)$end) - 
                                  min(as.data.frame(Aminor_AFPtransA_gr)$start)),
                                (max(as.data.frame(Aminor_AFPtransB_gr)$end) - 
                                  min(as.data.frame(Aminor_AFPtransB_gr)$start)),
                                (max(as.data.frame(Lmac_AFPsynt_gr)$end) - 
                                  min(as.data.frame(Lmac_AFPsynt_gr)$start)),
                                (max(as.data.frame(Lmac_AFPtransA_gr)$end) - 
                                  min(as.data.frame(Lmac_AFPtransA_gr)$start)),
                                (max(as.data.frame(Lmac_AFPtransB_gr)$end) - 
                                  min(as.data.frame(Lmac_AFPtransB_gr)$start))))


ggplot(data = TE_n_df,
       aes(x = AFP_n, y = log(TE_n/len))) +
  geom_smooth(method = "lm", se = FALSE, color = "black") +
  geom_point(aes(shape = species, color = region), size = 3) +
  theme_classic()

```

